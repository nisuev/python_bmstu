#Нисуев Нису ИУ7-12Б
#Интегрирование с помощью методов трапеции и правого прямоугольника
#Проверка точности методов
#Поиск у менее точного метода кол-ва разбиений, для которого интеграл будет вычислен с заданной точностью

#Функция
def f(x):
	#return 4
	return x ** 2

#Первообразная функции
def F(x):
	#return x *4
	return x ** 3 / 3
	
#Блок ввода начала и конца отрезка интегрирования
x_begin = None  # Начало отрезка интегрирования
while True:
	var = input('Введите начало отрезка интегрирования: ')
	try:
		x_begin = float(var)
		break
	except:
		print('Введите вещественное число')

x_end = None  # Конец отрезка интегрирования
while True:
	var = input('Введите конец отрезка интегрирования: ')
	try:
		x_end = float(var)
		if x_end <= x_begin:
			print(f'Конец отрезка должен быть больше начала отрезка интегрирования')
			continue
		break
	except:
		print("Введите вещественное число")
print()

#Функция для поиска определенного интеграла по формуле Ньютона-Лейбница
def Integral(begin, end):
	Int = F(end) - F(begin)
	return Int

I_true = Integral(x_begin, x_end) #Значение определенного интеграла


#Блок ввода участков разбиения
N1 = None  #Первое количество участков разбиения
while True:
	var = input('Количество участков разбиения N1: ')
	try:
		N1 = int(var)
		if N1 <= 0:
			print('Количество должно быть больше 0')
			continue
		break
	except:
		print('Введите целое число больше 0')

N2 = None  #Второе количество участков разбиения
while True:
	var = input('Количество участков разбиения N2: ')
	try:
		N2 = int(var)
		if N2 <= 0:
			print('Количество должно быть больше 0')
			continue
		break
	except:
		print('Введите целое число больше 0')
print()

#Функция для поиска интеграла методом правого прямоугольника
def right_rect(begin,end,div):
	step = (end - begin) / div #Шаг 
	s = 0 #Сумма площадей
	x = begin #Начало интервала
	while x < end:
		s += f(x + step) * step
		x += step #Счет площади правого прямоугольника
	s = float('{:.5g}'.format(s))
	return s

#Функция для поиска интеграла методом трапеции
def trapeze(begin,end,div):
	step = (end - begin) / div #Шаг
	x = begin #Начало интервала
	s = 0 #Сумма площадей
	while x < end:
		s += (f(x) + f(x + step)) / 2 * step #Счет площади трапеции
		x += step
	s = float('{:.5g}'.format(s))
	return s

meth = ['Метод правых прямоугольников', 'Метод трапеций'] #Список методов

I = [[right_rect(x_begin, x_end, N1), right_rect(x_begin, x_end, N2)],
[trapeze(x_begin, x_end, N1), trapeze(x_begin, x_end, N2)]] #Матрица значений интегралов

#Справка по матрицам
#                               N1    N2
# Метод правых треугольников  | I1    I2 | 
# Метод трапеций              | I3    I4 |
#
# строка - метод
# столбец - количество разбиений 

#Блок вывода таблицы найденных значений интегралов по методам
print('Таблица значений интегралов:')
#Шапка 
print('-'*64)
print('|{:^30s}|{:^15.5g}|{:^15.5g}|'.format('', N1, N2))
print('-'*64)
#Основной вывод
for i in range(2):
	print('|{:^30s}|'.format(meth[i]), end='')
	for j in range(2):
		print('{:^15.5g}'.format(I[i][j]), end='|')
	print()
print('-'*64, end='\n\n')

#Вывод значения определенного интеграла посчитанного по формуле Ньютона-Лейбница
print('Значение определенного интеграла: {:.5g}'.format(I_true), end='\n\n')

#Счет абсолютной погрешности
I_abs = [[0] * 2 for i in range(2)] #Матрица абсолютных погрешностей

min_inc = float('inf') #Поиск минимальной погрешности
ind_m = -1 #Индекс метода с минимальной погрешностью
for i in range(2):
	for j in range(2):
		I_abs[i][j] = abs(I_true - I[i][j]) #Счет абсолютных погрешностей
		if I_abs[i][j] < min_inc: #Поиск минимальной погрешности
			ind_m = i
		
#Счет относительной погрешности
I_rel = [['-'] * 2 for i in range(2)] #Матрица относительных погрешностей

for i in range(2):
	for j in range(2):
		#Проверка условий
		if I_true == 0: #Условия при определенном интеграле равном нулю
			if I_abs[i][j] == 0: #Абсолютная погрешность равна нулю
				I_rel[i][j] = '0%' #Погрешности нет(Идеально считает)
			else: #Абсолютная погрешность не равна нулю
				I_rel[i][j] = '-' #Относительная погрешность не может существовать
		else: #Если определенный интеграл не равен нулю
			I_rel[i][j] = '{:.5g}'.format((I_abs[i][j] / I_true) * 100) + '%' #Счет относительных погрешностей в процентах

#Вывод таблицы погрешностей
print('Таблица погрешностей')
#Шапка
print('-'*96)
print('|{:^30s}|{:^31.5g}|{:^31.5g}|'.format('', N1, N2))
print('|{:^30s}|{:^31s}|{:^31s}|'.format('', '-'*31, '-'*31))
print('|{:^30s}|{:^15s}|{:^15s}|{:^15s}|{:^15s}|'.format('', 'Абсолютная', 'Относительная', 'Абсолютная', 'Относительная'))
print('-'*96)
#Основной вывод
for i in range(2):
	print('|{:^30s}|'.format(meth[i]), end='')
	for j in range(2):
		print('{:^15.5g}|{:^15s}'.format(I_abs[i][j], I_rel[i][j]), end='|')
	print()
print('-'*96, end='\n\n')

#Вывод более точного метода по индексу
print(f'{meth[ind_m]} наиболее точный для заданной функции',end='\n\n')

#Блок ввода точности
eps = None  # Точность
while True:
	var = input('Введите точность: ')
	try:
		eps = float(var)
		break
	except:
		print('Введите вещественное число')


#Если метод правых прмоугольников более точный
if ind_m == 0: #Считаем задание по методу трапеций
	i = 1
	first = trapeze(x_begin, x_end, i)
	second = trapeze(x_begin, x_end, 2 * i)
	while abs(first - second) >= eps:
		i *= 2
		first = second
		second = trapeze(x_begin, x_end, i * 2)
	
	print(f'Менее точный, для заданной функции, метод трапеций достигает заданную точность {eps} при кол-ве разбиений = {i}')

#Если метод трапеций более точный
if ind_m == 1: #Считаем задание по методу правых прямоугольнков
	i = 1
	first = right_rect(x_begin, x_end, i)
	second = right_rect(x_begin, x_end, 2 * i)
	while abs(first - second) >= eps:
		i *= 2
		first = second
		second = right_rect(x_begin, x_end, i * 2)
		
	print(f'Менее точный, для заданной функции, метод правых прямоугольников достигает заданную точность {eps:.5g} при кол-ве разбиений = {i}')
